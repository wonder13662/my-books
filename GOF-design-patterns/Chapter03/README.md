# Chapter 3 생성 패턴
생성 패턴(creational pattern)은 인스턴스를 만드는 절차를 추상화하는 패턴입니다. 이 범주에 해당하는 패턴은 객체를 생성,합성하는 방법이나 객체의 표현 방법과 (소프트웨어) 시스템을 분리해 줍니다. 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생성 패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있습니다.

생성 패턴은 시스템이 상속보다는 복합 방법을 사용하는 쪽으로 진화되어 가면서 더 중요해지고 있습니다. 이 때문에 고정된 행동 집합을 정의하는 것보다는, 더 복잡한 행동을 만드는 데 필요한 구성요소가 될 수 있는 기본적인 행동 집합을 정의하는 쪽에 더 많은 관심과 노력이 들어가고 있습니다. 그러므로 특정 행동을 수행하는 클래스를 만들려면 단순하게 하나의 클래스를 인스턴스화하는 일 이상의 품이 들어갑니다.

생성 패턴이 나오면 항상 따라다니는 이야기가 두 개 있습니다.
1. 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화합니다.
2. 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려줍니다.

결론적으로, 생성 패턴을 이용하면 **무엇이** 생성되고, **누가** 이것을 생성하며, 이것이 **어떻게** 생성되는지, **언제** 생성할 것인지 결정하는 데 유연성을 확보할 수 있게 됩니다.

생성 패턴으로 분류되는 패턴은 여러 개인데, 이런 여러 생성 패턴들은 서로 보완적일 수도 있고 선택되기 위해 서로 경쟁적일 수도 있습니다. 즉, 동일한 문제 해결을 위해서 어떤 생성 패턴을 새용해야 할지 결정을 내리기가 어렵습니다.

인스턴스를 생성하고 복합하는 방법에 해당하는 부분과 이들 인스턴스를 사용하는 프로그램을 분리하고자 할 때 어떤 패턴을 적용해야 하는지 판단하기는 어렵습니다. 예를 들어, 원현 패턴과 추상 팩토리 패턴 중 무엇을 선택할지 고민해야 할 때가 있습니다. 어떨 때는 또 이들이 서로 보완적일 수도 있지요. 예를 들어, 빌더 패턴은 어떤 구성요소를 만들지 구현하는 데에 다른 생성 패턴 중 하나를 사용할 수 있습니다. 원형 패턴은 자기 자신의 구현을 위해 단일체 패턴을 사용하기도 합니다.

생성 패턴 간에는 매우 밀접한 관련성이 있기 때문에, 이들 간의 공통점과 차이점을 중심으로 다섯 개의 패턴을 공부하기로 하겠습니다. 그리고 하나의 예제를 통해 각 패턴의 설명을 진행할까 합니다. 바로 컴퓨터 게임에 넣을 미로를 만드는 문제입니다. 패턴에 따라 미로와 게임이 어떻게 조금씩 다르게 만들어지는지 잘 보시기 바랍니다. 단순히 미로에서 빠져나오는 게임일 때는 전체 미로 중 플레이어에게 보이는 만큼의 미로가 표시될 것입니다. 풀어야 할 문제가 있을 수도 있고, 극복해야 할 위험이 숨겨진 미로 게임일 때는 미로의 일부분에 해당하는 평면 지도가 제공되기도 합니다.

여기서는 복잡한 미로 게임을 다루지는 않을 것이며, 또 혼자 하는 게임인지 여러 사람이 하는 게임인지도 구분하지 않을 것입니다. 그보다는 미로를 어떻게 만들 것인가를 강조할 것입니다. 미로는 방들의 집합이고, 각 방은 옆에 무엇이 있는지 알고 있는데, 방 옆에 있는 것이 방일 수도 있고, 문일 수도 있고, 벽일 수도 있는 것입니다.

클래스 `Room`, `Door`, `Wall`은 우리가 개발하는 미로를 만드는 데 필요한 구성요소입니다. 이 요소에 대해서도 미로를 생성하는 데 중요한 클래스만 정의하겠습니다. 게임하는 사람, 미로 내에서 돌아다니는 방법, 화면에 디스플레이하는 방법, 또는 미로 구축과 상관없는 복잡한 내용들은 다루지 않을 것입니다.

다음 클래스 다이어그램은 클래스 간의 관련성을 보여줍니다.
![그림](3-0-001.gif)
각 방은 네 개의 방향을 갖는데, C++ 구현 시에는 나열자 타입으로 정의한 `Direction`을 사용하여 각 방향을 다음과 같이 선언합니다.
```c++
enum Direction {North, South, East, West};
```
스몰토크로 구현할 때도 역시, 각 방향을 나타내는 기호를 사용합니다.

`MapSite` 클래스는 미로의 구성요소들에 필요한 모든 연산을 정의한 공통 추상 클래스입니다. 예를 단순하게 하기 위해서 `MapSite`는 `Enter()` 연산 하나만을 정의하도록 합니다. `Enter()` 메서드는 무엇에 들어가느냐에 따라 그 의미가 달라질 것입니다. 즉, 방에 들어간다면 위치가 바뀌도록 구현해야 할 것입니다. 들어가는 것이 문이라면 이렇게 구현합니다. 문이 열려있으면 문을 통해 다른 방으로 들어가도록 구현하고, 문이 닫혀 있다면 상처를 입도록 구현하면 됩니다.
```c++
class MapSite {
  public:
    virtual void Enter() = 0; // 구현부를 갖지 않는 순수 가상 메서드
}
```
`MapSite`에 정의된 `Enter()`는 좀 더 섬세한 게임 동작을 만드는 데 쓸 수 있는 기본 연산입니다. 만약, 방에 있을 때 "동쪽으로 가시오"라고 구현하고 싶으면, 게임은 어떤 `MapSite`가 동쪽에 인접한 것인지 판단한 후 그 대상에 정의된 `Enter()`를 호출하도록 메서드를 구현합니다. `MapSite`의 서브클래스가 어떤 것이냐에 따라 `Enter()`는 위치를 변경하도록 구현할 수도 있고, 이동을 못하고 상처를 입도록 구현할 수도 있습니다.

`Room` 클래스는 `MapSite`를 상속받은 구체적인 클래스로 미로에 있는 다른 요소와 관련성을 갖도록 정의합니다. 다른 요소들 어느 것과도 관련성을 가질 수 있으므로 `Room`은 다른 요소들의 부모 클래스인 `MapSite`와 연결 관계를 갖는 것으로 모델링합니다. `Room` 클래스는 방 번호를 저장하는데, 이 번호로 미로에 있는 방을 식별할 수 있습니다.
```c++
class Room : public MapSite {
  public:
    Room(int RoomNo);

    MapSite* GetSide(Direction) const;
    void SetSide(Direction, MapSite*);

    virtual void Enter();
  private:
    // 방은 네 개의 방향을 갖고 있고
    // 각 방향에는 MapSite의 서브클래스 인스턴스가 올 수 있습니다.
    MapSite* _sides[4];
}
```