# 객체 생성(Object Creational): 추상 팩토리(ABSTRACT FACTORY)
## 의도
상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공합니다.
## 다른 이름
키트(Kit)
## 동기
모티프와 프레젠테이션 매니저와 같은 사용자 인터페이스 툴킷을 살펴보면, 서로 다른 룩앤필 표준을 가지고 있습니다. 서로 다른 룩앤필은 서로 다른 사용자 인터페이스의 표현 방식과 행동을 갖습니다. 스크롤바, 윈도우 버튼은 모양이 다르고 동작 방식도 서로 다릅니다. 개발한 응용프로그램이 서로 다른 룩앤필 표준에 상관없이 이식성을 가지려면, 응용프로그램이 각 사용자 인터페이스 툴킷에서 제공하는 위젲을 직접 사용하지 못하도록 해야 합니다.

이런 문제는 구체적 사용자 인터페이스의 위젯을 사용하지 말고 추상 클래스인 `WidgetFactory`를 정의하여 해결하는 게 좋습니다. `WidgetFactory` 클래스는 위젯의 기본 사용자 인터페이스 요소(윈도우, 스크롤바, 버튼 등)을 생성할 수 있는 인터페이스를 정의합니다. 그리고 응용프로그램은 필요한 사용자 인터페이스 요소를 `WidgetFactory`에 생성해 줄 것을 요청하여, 필요한 요소의 인스턴스를 얻어옵니다. 물론, 실제적으로 구현 종속적인 인스턴스를 생성하기 위해서는 팩토리와 구분하여 각각의 위젯별로 추상화된 클래스를 정의해야 하고, 이를 상속하는 구체적인 서브클래스를 정의하여 구체적 룩앤필 표준에 대한 구현을 제공합니다.

예를 들어, `Window`라는 개념의 사용자 인터페이스가 있다면 인스턴스를 생성하는 팩토리와 구분하여 생성할 룩앤필의 표준에 대응하는 `Window` 클래스를 추상 클래스로 정의합니다. 그러고 나서 각 사용자 인터페이스 툴킷이 제공하는 위젯 및 구현 방식에 따라 `PMWindow`, `MotifWindow`를 정의합니다.

`WidgetFactory` 인터페이스는 각 추상화된 위젯 클래스의 인스턴스를 생성하여 반환하는 연산을 정의합니다. 사용자는 `WidgetFactory`에 원하는 요소의 인스턴스를 생성하는 연산을 호출하여 위젯의 인스턴스를 얻게 됩니다. 그러나 사용자는 `WidgetFactory`를 상속받은 어떤 구체적 서브클래스가 이들 연산을 구현하여 결과를 반환하는지 알 수 없고, 알 필요도 없습니다. 즉, 사용자는 팩토리에만 메시지를 보낼 뿐이지, `PMWindow`에 메시지를 보내는지, `MotifWindow`에 보내는지는 알 필요가 없습니다. 이로써 사용자는 룩앤필과 분리될 수 있습니다.

이 패턴을 사용하기 위해서는 `AbstractFactory`에 해당하는 `WidgetFactory`뿐만 아니라 각 룩앤필 표준에 대한 `WidgetFactory`를 상속받는 구체 서브클래스들을 정의해야 합니다. 
![그림](3-1-001.gif)
위 그림에 정의된 모델을 보면 `WidgetFactory` 및 이 클래스의 서브클래스들과 이들이 생성하는 위젯 클래스 간의 모델이 표현되어 있습니다. `WidgetFactory`를 상속받은 서브클래스들인 `MotifWidgetFactory`와 `PMWidgetFactory`가 구체적 룩앤필에 정의된 실제 위젯을 생성하는 연산을 구현합니다. 즉, `MotifWidgetFactory`에 정의된 `CreateScrollBar` 연산은 모티프의 스크롤바를 반환하고, `PMWidgetFactory`에 있는 해당 연산은 프레젠테이션 매니저에 필요한 스크롤바를 생성해서 반환합니다. 그러나 사용자는 이런 내부 처리와 상관없이, `WidgetFactory` 인터페이스를 통해서만 추상화된 위젯을 생성합니다.

`WidgetFactory`를 사용하면 구체 위젯 클래스 사이에 의존 관계가 만들어집니다. 모티프의 스크롤바는 모티프 버튼 및 모티프 텍스트 편집기와 함께 사용되어야 하는 것이죠. `MotifWidgetFactory`를 쓴 결과로 자동으로 생긴 제약입니다.
## 활용성