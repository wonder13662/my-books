# 2.8 철자 검사 및 붙임표 연결
마지막 설계 문제는 텍스트 분석입니다. 여기서는 철자 오류 검사, 그리고 보기 좋은 편집을 위한 붙임표 삽입에 대한 해결책을 찾아보겠습니다.

여기서 제약 사항은 [2.3 서식 설정](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter02/2-3.md)에서 서식 설정 문제를 해결할 때의 제약과 비슷합니다. 라인 분리자 전략에서도 그랬지만, 철자 검사와 붙임표 위치를 구하는 방법은 한두가지가 아닙니다. 그래서 여기서도 우리는 다양한 알고리즘을 지원하고 싶습니다. 다양한 알고리즘이 있다면 공간, 시간, 품질에 따른 선택의 폭을 사용자에게 제공할 수 있습니다. 마찬가지로, 새로운 알고리즘 추가도 쉬워야 할 것입니다.

이와 더불어, 문서 구조 안에는 이러한 기능이 엮여 들어가지 않았으면 좋겠습니다. 지금 이 목표는 서식 설정 문제를 처리할 때 있었던 목표보다 더 중요한데, 그 이유는 철자 검사나 붙임표 지점 설정 기능은 Lexi가 제공했으면 하고 바라는 다양한 분석 기법 중 일부분이기 때문입니다. 이런 텍스트 분석 기능은 확실히 확장이 필요합니다. 탐색, 단어 갯수 세기, 테이블의 값 합산 등 계산 기능, 문법 검사 등 다양한 기능이 계속적으로 추가될 수 있는 틀을 만들고 싶은 것 입니다. 그러나 이런 기능을 추가할 때마다 Glyph 클래스나 이를 상속하는 서브클래스들을 변경하고 싶지는 않습니다.

이 퍼즐을 풀려면 두 가지 조각을 맞추면 됩니다. 
1. 분석될 정보에 접근하는 것인데, 이 정보는 문서 구조를 나타내는 여러 글리프에 흩어져 있습니다.
2. 분석을 직접하는 것입니다.
이 두 문제를 각각 따로 살펴보도록 합시다.

## 흩어진 정보에 대한 접근
전부는 아니지만 대다수 분석 작업에서는 글자 단위의 분석이 필요합니다. 우리가 분석해야 하는 텍스트는 글리프 객체의 계층 구조에 흩어져 있습니다. 이런 구조에서 텍스트를 검사하려면 객체를 저장하고 있는 데이터 구조에 대한 지식이 있어야 합니다. 이런 계층 구조를 연결 리스트로 저장해 두었을 수도 있고, 배열로 만들어졌을 수도 있고, 아니면 또 다른 복잡미묘한 구조일 수도 있습니다. 어쨌든, Lexi에서 쓰는 정보 접근 방법은 이런 모든 가능성을 처리할 수 있어야 합니다.

여기에 딸린 복잡한 문제가 하나 더 있는데, 바로 분석 방법마다 정보에 접근하는 방법이 제각기 다르다는 것입니다. 대부분의 분석은 텍스트를 앞에서 뒤로 분석해가지만, 어떨 때는 반대로 할 수도 있습니다. 산술 표현식을 평가할 때는 중위 순회(inorder traversal) 방법을 써야 합니다.

결론은 두 가지입니다. Lexi에서 쓰는 접근 방법은 서로 다른 데이터 구조를 포괄살 수 있어야 하며, 서로 다른 순회 방법(후위(postorder), 중위(inorder), 전위(preorder) 등)이 지원되어야 합니다.

## 접근과 순회 방법을 캡슐화하기
현재의 Glyph 인터페이스는 자식들을 참조하는 데에 정수형 지정번호를 사용합니다. 자식을 배열에 저장한 글리프 클래스에 대해서는 이런 방식이 타당합니다만, 연결 리스트를 사용하는 글리프 클래스에서라면 효율이 좋지 않을 것입니다. 글리프 추상화의 가장 큰 의의는 자식들을 저장하는 자료 구조를 외부에 숨기는 것이었습니다. 이렇게 해야만 다른 클래스에 영향을 주지 않고 자료 구조를 마음대로 변경할 수 있습니다.

그러므로 글리프는 단지 데이터 구조를 사용한다는 것만 알 뿐, 무슨 데이터 구조를 사용하는지는 몰라야 한다는 것입니다. 이를 위해서 어떤 데이터 구조에도 치우치지 않는 인터페이스를 정의해야 합니다. 즉, 인터페이스를 보고 글리프가 사용하는 데이터 구조가 무엇인지를 판단할 수 있으면 안 됩니다.

이런 문제를 해결하면서 한번에 다양한 순회 방뻐을 제공하는 방법은 여러가지 입니다. 이들 중, 글리프들의 클래스에 접근과 순회 기능을 다양하게 구현하고 이 중 하나를 선택하게 하는 방법을 생각해 볼 수 있습니다. 클래스는 순회 방법이나 접근 방법을 나타내는 나열형(enumerated) 값 중 하나를 선택해서 연산의 매개변수로 전달합니다. 동일한 종류의 순회를 수행하고 있음을 확인하기 위해서 순회동안 내내 접근 방법을 매개변수로 전달해야 합니다. 또한 순회를 진행하는 동안 축적된 정보를 계속 전달해야 합니다.

이 방법을 지원하기 위해, Glyph 인터페이스에 다음 추상 연산을 추가합니다.
```c++
void First(Traversal kind) // 나열형 값 중에서 사용할 순회 방법이나 접근 방법을 매개변수로 전달

void Next()
bool IsDone()
Glyph* GetCurrent()
void Insert(Glyph*)
```
`First()`, `Next()`, `IsDone()`은 순회를 처리하는 연산입니다. `First()`는 순회의 초기화를 맡는데, 초기화할 때 순회의 종류를 매개변수로 받고 있습니다. 여기서 `Traversal` 타입은 순회의 종류를 상수로 정의한 나열형 타입입니다. 예를 들어, 자식만 순회하는 `CHILDREN`, 전위 순회에 해당하는 `PREORDER`, 후위 순회에 해당하는 `POSTORDER` 중위 순회에 해당하는 `INORDER` 등이 나열형 값으로 들어갑니다. `Next()` 연산은 순회 순서상 다음 요소로 이동하는 것이고, `IsDone()`은 이 이상 순회할 요소가 더 있는지 없는지를 알려줍니다. `GetCurrent()` 연산은 현재 글리프로 접근하는 연산입니다. 이 연산은 `Child()` 연산으로 대체할 수도 있습니다. `Insert()`는 현재 위치에 글리프를 추가하는 연산으로, 예전에 정의한 것과 다릅니다.

전위 순회 방식을 써서 어떤 텍스트 분석 연산을 C++를 이용하여 구현하면 다음과 같습니다.
```c++
Glyph* g;
for (g->First(PREORDER); !g->IsDone(); g->Next()) {
  Glyph* current = g->GetCurrent();
  // 분석 수행
}
```
glyph 인터페이스는 이제 정수형 지정번호를 쓰지 않습니다. 예전처럼 특정 종류의 데이터 구조에 치우친 인터페이스가 아닙니다. 이렇게 되면 사용자 쪽에서 일반화된 순회 알고리즘을 구현해야 하는 노력이 많이 줄어듭니다.

그러나 이 방법에도 여전히 문제가 남아있습니다. 새로운 순회 방법을 추가하려면 나열형 값을 변경하거나 새로운 연산을 추가해야 하기 때문입니다. 전위 순회 방법을 사용하되, 문자가 아닌 것은 자동으로 넘어가는 방법을 원한다고 합시다. 이것을 위해서는 `TEXTUAL_PREORDER` 같은 상수를 `Traversal` 나열형 타입에 추가해야 합니다.

이런 식으로 기존 선언문을 바꾸는 건 별로 좋지 않을 것 같습니다. Glyph 클래스 구조에 순회 방법을 넣으면 순회 방법을 수정하거나 확장하려 할 때 반드시 여러 Glyph 클래스 서브클래스를 변경해야 할 테니까요. 그리고 다른 구조에 대해 동일한 순회 방법을 다시 사용할 수도 없고, 하나의 구조가 순회 방법을 여러 개 지니도록 만들 수도 없게 됩니다.

비슷한 이야기를 앞에서 한 것 같지만, 다양성을 지닌 개념은 하나의 클래스로 캡슐화하는 것이 좀 더 나은 해법이 될 수 있습니다. 여기서 "다양성을 지닌 개념"은 정보 접근과 순회 방법입니다. 바로 이럴 때 iterator 객체를 도입할 수 있습니다. 이 객체의 목적은 다양한 접근과 순회 방법을 일반화해서 정의하는 것입니다. 상속을 이용해서 다른 데이터 구조에 동일하게 접근할 수 있을 뿐더러 새로운 종류의 순회도 제공할 수 있습니다. 그리고 glyph 인터페이스를 변경하거나 기존 구현을 어지럽히지 않아도 됩니다.

## Iterator 클래스와 서브클래스
구조 접근과 순회에 필요한 일반 인터페이스를 정의하는 용도로 **Iterator** 추상 클래스를 사용하려고 합니다. 이 인터페이스는 **Iterator** 서브클래스 쪽에서 구현하게 되는데, 이를테면 **ArrayIterator**는 배열로 접근하고 **ListIterator**는 리스트로 접근하며, 이 외에 **PreorderIterator**, **PostorderIterator** 등은 트리 구조를 순회하는 식으로 구현될 것입니다. Iterator의 각 서브클래스는 자신이 순회할 구조에 대한 참조자를 가지며, 서브클래스의 인스턴스는 자신이 생성될 때 자신이 순회할 데이터 구조에 대한 참조자로 초기화됩니다. [그림 2.13]()은 이 관계를 보여주고 있습니다. 이러한 반복자를 지원하기 위해 Glyph 클래스 인터페이스에 추상 연산인 `CreateIterator()`를 추가해 둔 부분을 눈여겨 둡시다.

![그림](2-8-001.gif)
#### 그림 2.13 Iterator 클래스와 서브클래스

Iterator 인터페이스에는 순회를 제어하기 위해 `First()`, `Next()`와 `IsDone()` 연산이 있습니다. ListIterator 서브클래스는 리스트의 첫 번째 원소를 가리키도록 `First()` 연산을 구현할 것이고, `Next()` 연산은 리스트의 다음 원소로 이동하도록 구현하고, `IsDone()` 연산은 순회할 원소가 있는지 없는지를 알려주도록 구현할 것입니다. `CurrentItem()`은 Iterator 객체가 가리키는 원소를 객체화하여 반환합니다. 한편, `ArrayIterator`는 이들 연산을 배열의 특성에 맞추어 구현할 것입니다.

이제 내부 표현을 모르는 상태에서 구조에 접근하는 코드를 작성해 봅시다.
```c++
Glyph* g;
Iterator<Glyph*>* i = g->CreateIterator();
  // Glyph 객체를 순회할 Iterator 객체를 얻음
for (i->First(); !i->IsDone(); i->Next()) {
  Glyph* child = i->CurrentItem();
  // 얻어온 현재 자식으로 무엇인가를 처리하는 코드 작성
}
```
`CreateIterator()` 연산의 기본 구현은 NullIterator 객체를 반환하도록 되어 있습니다. NullIterator 객체를 반환함으로써 자식들을 갖지 않는 글리프는 Iterator 객체를 사용하지 않도록 하기 위한 방법입니다. NullIterator 객체의 `IsDone()` 연산은 항상 true 값을 반환합니다.

자식을 갖는 glyph 서브클래스라면 `CreateIterator()` 연산을 재정의하여 Iterator 서브클래스의 인스턴스를 반환하면 됩니다. 어떤 서브클래스가 필요한지는 자식을 저장한 구조에 따라 달라집니다. Glyph의 서브클래스인 Row 클래스가 자식을 리스트에 저장한다면, `CreateIterator()` 연산은 다음과 같이 ListIterator 객체를 반환하도록 재정의합니다.
```c++
Iterator<Glyph*>* Row::CreateIterator () {
  return new ListIterator<Glyph*>(_children);
}
```
전위 순회와 중위 순회 방식으로 동작하는 서브클래스 역시 자신만의 순회 방법을 구현하고 있을 것입니다. 이들 PreorderIterator와 PostorderIterator 클래스는 순회하는 트리 구조의 최상위 글리프(루트 노드)에서 순회 방법을 구현한 Iterator 객체가 무엇인지 알아냅니다. 그리고 Glyph 클래스 인스턴스인 _root 객체의 `CreateIterator()` 연산을 호출하며, 순회 과정을 추적하기 위해서 스택을 이용합니다.

예를 들어, `PreorderIterator` 클래스는 최상위 글리프 객체인 `_root`에서 반복자(iterator)를 얻어서, 자신이 가리킬 첫 번째 원소로 초기화하고 스택에 저장합니다.
```c++
void PreorderIterator::First() {
  Iterator<Glyph*>* i = _root->CreateIterator();

  if (i) {
    i->First();
    _iterators.RemoveAll();
    _iterators.Push(i);
  }
}
```
`CurrentItem()` 연산은 스택의 상단에 위치한 반복자의 `CurrentItem()` 연산을 호출합니다.
```c++
Glyph* PreorderIterator::CurrentItem () const {
  return
    _iterators.Size() > 0 ? 
    _iterators.Top()->CurrentItem() : 0;
}
```
`Next()` 연산은 스택의 최상위에 있는 반복자들의 값을 얻어서 현재 원소를 구해 온 다음 반복자를 생성하게 합니다. 새로운 반복자를 첫 번째 항목으로 하고 스택에 넣습니다. 그리고 마지막 반복자인지 확인하고 마지막이 아니면 스택에서 하나를 읽어와서 이 처리를 계속 반복합니다. 마지막이면 순회를 마칩니다. 이를 코드로 확인하면 다음과 같습니다.
```c++
void PreorderIterator::Next () {
  Iterator<Glyph*>* i = _iterators.Top()->CurrentItem()->CreateIterator();

  i->First();
  _iterators.Push(i);

  while (
    _iterators.Size() > 0 && _iterators.Top()->IsDone()
  ) {
    delete _iterators.Pop();
    _iterators.Top()->Next();
  }
}
```
이러한 `Iterator` 클래스 계층의 덕택으로, 새로운 종류의 순회 방법을 추가할 때 기존 Glyph 클래스를 수정하지 않아도 됩니다. 방금 PreorderIterator 클래스를 가지고 한 것처럼 `Iterator` 클래스의 서브클래스를 만들고 새로운 순회방법을 추가하면 끝인 것이죠. 데이터 구조를 공개할 필요 없이 사용자가 자식들을 접근할 수 있도록 Glyph 서브클래스들은 동일한 인터페이스를 사용합니다. `Iterator` 클래스가 바뀌더라도 사용자는 변경을 눈치 챌 수 없습니다. `Iterator`는 순회의 상태에 대한 각자의 사본을 저장하고 있기 때문에, 심지어 하나의 구조에 대해서도 여러 개의 순회를 동시에 진행할 수 있습니다. 이번 예제에서는 글리프 구조를 따라 순회가 진행됐지만, `PreorderIterator`와 같은 클래스를 다른 자료 구조를 순회할 수 있는 객체의 타입으로서 매개변수화하지 못할 이유도 없습니다. C++의 템플릿을 사용하면 쉽게 구현할 수 있습니다. 그렇게 한 후, `PreorderIterator`를 재사용하여 다른 구조를 순회할 수도 있는 것입니다.