# 다중 윈도우 시스템 지원
룩앤필은 이식성을 생각할 때 불거지는 수많은 문제 중 하나일 뿐입니다. 또 다른 문제는 Lexi가 실행되는 윈도우 환경입니다. 보통 한 플랫폼에서 운영되는 윈도우 시스템은 비트맵 디스플레이에서 윈도우를 만들어 내고, 윈도우 화면 위의 공간을 관리하며, 키보드나 마우스에서 받은 입력을 윈도우에 전달합니다. 현실적으로, 우리가 자주 사용하는 대부분의 윈도우 시스템은 서로 호환성이 없습니다(예를 들어, 매킨토시, 프레젠테이션 매니저, Windows, X). Lexi는 여러 룩앤필 표준을 지원한다는 똑같은 명분이 있으므로, 가능하면 여러 윈도우 시스템에서 실행되었으면 합니다.
## 추상 팩토리 패턴을 사용할 수 있을까요?
먼저 생각해 볼 수 있는 것이, 앞에서 이야기한 추상 팩토리 패턴을 사용할 수 있을까 하는 문제입니다. 윈도우 시스템 간의 이식성은 앞에서 본 룩앤필 표준에 대한 독립성과는 사뭇 다른 점이 있습니다.

추상 팩토리 패턴을 적용할 때는 각 룩앤필 별로 정확한 위젯 클래스를 정의할 것이라고 가정했습니다. 이 말은 특정 표준별로 추상 제품 클래스에서 각각 구체적인 제품을 만들 수 있다는 것이며, `ScrollBar` 클래스가 있으면 표준별로 `MotifScrollBar` 클래스와 `MacScrollBar` 클래스를 만들 수 있음을 의미합니다. 즉, 각 위젯별로 하나의 추상 클래스를 추출할 수 있어 추상 팩토리 패턴의 사용이 가능합니다. 윈도우 시스템은 각 회사마다 서로 다른 여러 개의 클래스 계층을 이미 가지고 있는데, 이 계층이 서로 호환 가능하다고 볼 수 없기 때문에 각각 위젯별로 공통의 추상 클래스를 정의할 수 없습니다. 다시 말해, `ScrollBar`, `Button`, `Menu` 같은 각 위젯에 대해서 하나의 `Product`라는 클래스를 정의할 수 없다는 것입니다. 이때는 추상 팩토리 패턴을 적용할 수 없으므로, 제품이 갖는 인터페이스에서 공통된 연산을 정의하는 별도의 위젯 계층을 만들어야 합니다.

추상 팩토리 클래스의 인터페이스에 선언할 수 있는 공통의 연산이라면 그것은 `CreateXXX()` 연산일 것입니다. 이 말은 위젯들 간에 호환성을 위해서 우리 나름대로 추상 클래스와 구체적인 제품 클래스 모두를 만들어야 한다는 의미이기도 합니다.

허나, 그래도 다행인 점은 룩앤필 표준에서도 그랬듯이 윈도우 시스템의 인터페이스 역시 심각하게 다르지 않다는 것입니다. 윈도우 시스템이 하는 일이 비슷비슷하기 때문입니다. 단, 하는 일은 비슷하지만 구현하는 방법은 완전히 다르므로 윈도우가 하는 일에 대한 추상화와 이를 구현하는 방법의 추상화를 분리시켜야 합니다. 윈도우가 하는 일이란 윈도우 시스템의 인터페이스를 의미하고, 이를 구현하는 방법이란 실제 윈도우 시스템이 제공하는 프로그래밍 인터페이스를 의미합니다. 즉, 해야 하는 일들은 비슷하지만, 이를 만족하는 구체적인 방법이 서로 다를 수 있기 때문에, 이 둘을 분리하자는 것입니다.

## 구현 종속성을 캡슐화
[2.2 문서 구조](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter02/2-2.md)에서 화면에 표시되는 글리프나 글리프 구조를 위한 Window 클래스를 선보인 바 있습니다. 그러나 이들 객체가 동작할 윈도우 시스템을 명시하지는 않았습니다. 왜냐하면 Window 클래스는 어떤 특정 윈도우 시스템에서 얻어온 개념이 아니라 전체 윈도우 시스템 전반에 걸쳐서 하는 일을 추상화한 것이기 때문입니다. 즉, 이 클래스는 서로 다른 윈도우 시스템에서 공통적으로 수행하는 다음과 같은 것들을 캡슐화합니다.
- 기본적인 기하학적 도형을 그릴 수 있는 연산을 제공합니다. 
- 아이콘 상태가 될 수도 있고 아이콘 상태에서 해제될 수도 있습니다.
- 크기 변경이 가능합니다. 
- 요청이 있을 때 콘텐츠를 (다시) 그립니다. 이를테면, 아이콘에서 원상 복구되거나 중첩된 부분이 화면에 보일 때 다시 작성하는 것입니다.
Window 클래스는 윈도우 시스템과 상관없이 서로 다른 윈도우 시스템에서 기능성을 확장할 수 있습니다. 이를 위한 다음 두 가지의 극단적인 원칙을 검토해 봅시다.

1. 기능성의 교집합으로만 인터페이스를 정의
   - Window 클래스의 인터페이스는 모든 시스템에 공통되는 기능성만을 연산으로 정의합니다. 이 방법의 문제는 최소한의 기능을 제공하는 윈도우 시스템에서만 Window 인터페이스의 기능을 사용할 수 있습니다. 모든 윈도우 시스템이 갖는 공통의 연산만을 인터페이스로 정의한다면, 전부는 아니더라도 대부분의 윈도우 시스템이 제공하는 고급 기능들은 사용할 수 없습니다.
2. 기능성의 합집합으로만 인터페이스를 정의
   - 기존에 존재하는 모든 시스템이 갖고 있는 기능들을 모두 인터페이스에 정의하는 방법입니다. 이 방법의 문제는 인터페이스가 너무 크고 응집력이 없다는 점과 제조사가 윈도우 시스템의 인터페이스를 개정할 때마다 우리의 인터페이스도 변경해야 한다는 점 입니다.
### 표 2.3
#### Window 클래스의 인터페이스
|책임|연산|
|---|---|
|윈도우 관리|virtual void Redraw()<br>virtual void Raise()<br>virtual void Lower()<br>virtual void Iconify()<br>virtual void Deiconify()<br>...|
|그래픽 처리|virtual void DrawLine(...)<br>virtual void DrawRect(...)<br>virtual void DrawPolygon(...)<br>virtual void DrawText(...)<br>...|

이 두 방법은 모두 문제가 있기 때문에, 그 중간 방법을 선택해야 할 것입니다. Window 클래스는 대부분의 윈도우 시스템이 제공하는 기능을 인터페이스로 제공합니다. Lexi가 Window 클래스를 직접 다루므로 Window 클래스는 Lexi가 알고 있는 글리프들을 모두 지원해야 합니다. 다시 말해, Window의 인터페이스는 글리프 자체를 윈도우에 그리는 연산들을 전부 포함해야 한다는 것입니다. [표 2.3]()에 Window 클래스에 정의할 인터페이스를 정리하였습니다. 

Window는 추상 클래스이고 Window를 상속하는 서브클래스들이 사용자가 다룰 서로 다른 종류의 윈도우를 지원합니다. 예를 들어, Window 서브클래스는 응용프로그램 윈도우, 아이콘, 경고 창 등 다양한 종류의 윈도우를 지원합니다. 그러므로 
