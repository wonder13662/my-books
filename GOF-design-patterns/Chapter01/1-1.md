# 1.1 디자인 패턴이란?
건축가이자 패턴의 아버지, 크리스토퍼 알렉산더는 "각 디자인 패턴은 기존 환경 내에서 반복적으로 일어나는 문제들을 설명한 후, 그 문제들에 대한 해법의 핵심을 설명해 줍니다. 똑같은 방법으로 두 번 하지 않고 이 해법을 100만 번 이상 재사용할 수 있도록 말이죠."라고 하였습니다. 알레산더가 말한 것은 물론 시가지나 빌딩에 대한 이야기이긴 하지만, 객체지향 설계에도 해당됩니다. 소프트웨어 개발에서 해법은 벽이나 문들 대신 객체와 인터페이스를 사용하지만, 둘 모두 패턴을 "어떤 상황의 문제에 대한 해법"으로 본다는 공통점이 있습니다.

일반적으로 하나의 패턴에는 다음의 네 가지 요소가 반드시 들어 있습니다.

1. **패턴 이름(pattern name)**은 한두 단어로 설계 문제와 해법을 서술합니다. 패턴에 이름을 부여하는 것은 설계 어휘를 늘리는 일이며, 높은 수준의 추상화된 설계를 할 수 있도록 해 줍니다. 패턴의 이름을 정의해 두면 문서에 이 이름을 사용하여 설계의 의도를 표현할 수 있게 됩니다. 또 이렇게 이름을 갖게 되면 설계에 대한 생각을 더욱 쉽게 할 수 있고, 개발자들 간의 의사소통이 원활해집니다. 이 때문에 좋은 이름을 생각해 내는 것은 카탈로그를 설정하는 데 있어서 가장 힘든 부분 중의 하나이기도 합니다.

2. **문제(problem)**는 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명합니다. 즉, "어떤 알고리즘을 객체로 만들까"와 같은 설계의 세밀한 문제를 설명할 수 있씁니다. 때론 유연성없는 설계가 될 징조를 보이는 클래스나 객체의 구조를 제시합니다. 문제를 제시함으로써 패턴을 적용하는 것이 의미있는 사례들을 정의하기도 합니다.

3. **해법(solution)**은 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술합니다. 그렇다고 해법이 어떤 구체적인 설계나 구현을 설명하지는 않습니다. 왜냐하면 패턴은 다양한 경우에 적용할 수 있는 템플릿(template)이기 때문이죠. 구체적인 부분 대신, 디자인 패턴은 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공합니다.

4. **결과(consequence)**는 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술합니다. 어떤 설계를 결정할 때 그 설계의 결과를 고려하지 않기가 쉬운데, 어떻게 보면, 선택하는 과정에서 또는 비용과 효과를 측정하는 과정에서 설계의 결과는 가장 중요한 부분입니다. 소프트웨어에서 결과란 가끔 시간이나 공간 사이의 균형일 수 있습니다. 즉, 시간을 중요한 요소로 볼 것인지 아니면 저장 공간의 효율을 중요한 요소로 볼 것인지에 따라 다른 설계 방법을 선택해야 한다는 것입니다. 또한 언어에 따라서도 차이가 있습니다. 재사용은 객체 지향 설계의 주요 요소이므로, 패턴의 결과는 시스템의 유연성, 확장성, 이식성 등에 커다란 영향을 줍니다. 그래서 이런 설계의 결과들을 잘 정리해두면 나중에 패턴들을 이해하거나 평가하는 데 도움을 받을 수 있습니다. 

패턴에 대한 시각은 패턴을 구분하고 분석하는 데 영향을 줍니다. 어떤 사람에게는 그것이 패턴이지만, 다른 사람에게는 지극히 기초적인 조립용 부품으로 보일 수도 있는 거죠. 이 책에서 우리는 어느 정도 수준의 추상화를 갖는 패턴까지만 설명하는 것에 집중하였습니다. **디자인 패턴**은 연결 리스트와 해시 테이블 등을 클래스로 표현하고 그것 자체로 다시 쓸 수 있도록 설계하는 문제를 어떻게 푸느냐에 관한 것이 아닙니다. 응용프로그램 전체나 서브시스템을 지원하는 복잡한 설계에 대한 것은 더더욱 아니고요. 이 책에서 이야기하는 디자인 패턴은 "**특정한 전후 관계에서 일반적인 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명**"입니다.

하나의 디자인 패턴은 재사용 가능한 객체지향 설계를 만들기 위해 유용한 공통의 설계 구조에서 주요 요소들을 식별하여 이들에게 적당한 이름을 주고 추상화합니다. 그리고 패턴에 참여하는 클래스와 그들의 인스턴스를 식별하여 역할과 그들간의 협력 관계를 정의하고 책임을 할당합니다. 각 디자인 패턴은 각자 맡은 객체지향 설계 문제에 집중합니다. 언제 패턴을 적용할지, 다른 설계 제약을 고려하여 패턴을 적용할 수 있는지, 패턴을 사용하면 어떤 결과가 발생하는지도 친절히 설명합니다. 마지막으로, 각 패턴에서 제시한 설계는 구현하는 데 그 의미가 있으므로, C++와 (간간이) 스몰토크로 만든 예제 코드가 제시됩니다.

디자인 패턴이 객체 지향 설계를 서술하기 때문에 우리는 디자인 패턴을 구현할 때 절차적(precedual) 언어인 Pascal, C, Ada나 동적 객체지향 언어인 CLOS, Dylan, Self 등을 쓰지 않고, 가장 널리 사용되는 객체지향 언어인 스몰토크나 C++를 써서 구현하였습니다. 그 이유는 우리가 매일 경험하는 언어가 이것이었고, 사용자가 점점 늘어나는 언어 또한 이 두 언어이기 때문입니다(원 출간년도가 1994년임에 주목합시다).

어떤 프로그램 언어를 선택할 것인가는 개발자들에게 많은 영향을 주기 때문에 중요합니다. 패턴들은 잠정적으로 스몰토크나 C++ 레벨 언어의 특징을 전제로 무엇이 구현 가능하고 무엇은 구현이 힘든지를 결정하였습니다. 만일 절차적인 언어를 가정했다면, 아마 디자인 패턴에 상속, 캡슐화, 다형성 자체도 패턴으로 포함해야 했을 것입니다. 어떤 패턴들은 좀 덜 알려진 객체지향 언어에 기본적으로 구현되어 있을 때도 있습니다. 예를 들어, CLOS는 다중 메서드를 제공하기 때문에 방문자 패턴처럼 패턴의 필요성을 줄여줍니다. 사실, 스몰토크와 C++ 사이에도 많은 다른 점이 있어서 어떤 패턴은 한쪽 언어로 표현하기 쉬운 반면에 다른 쪽 언어로 표현하기는 어려울 수도 있습니다(반복자 패턴이 대표적인 예입니다. 스몰토크에는 반복자를 정의하는 컬렉션 클래스들이 이미 있습니다).