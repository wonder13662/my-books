# 1.8 디자인 패턴 사용 방법
디자인 패턴을 선택하고 나서 어떻게 그것을 사용할 수 있을까요? 다음은 디자인 패턴을 효율적으로 응용하기 위한 접근 방법을 단계적으로 정리한 내용입니다.

1. 전체를 훑는 기분으로 끝까지 한번 쭉 읽어주세요.
  - 패턴이 우리 문제에 적합하다는 것을 확신하려면 패턴의 활용성과 결과에 주의를 기울여야 합니다.
2. 이제 다시 처음으로 돌아가, '구조(Structure)', '참여자(Participant)', '협력 방법(Collaboration)' 절을 다시 공부하세요.
  - 패턴에 정의한 클래스와 객체를 이해하고 이들이 어떻게 동작하는지 이해해야 합니다.
3. 더 확실하게 이해하기 위해서 예제 코드 부분을 살펴보세요.
  - 코드를 공부하는 것은 패턴 구현법을 배우는 데 도움이 됩니다.
4. 응용프로그램에 의미 있는 이름으로 패턴의 참여자 이름을 결정하세요.
  - 디자인 패턴에 정의한 참여자들의 이름은 응용프로그램에 의미가 있기보다는 매우 추상적인 것입니다. 이 참여자의 이름을 응용프로그램에서 사용할 이름으로 바꾸어야 합니다. 이것은 구현에서 패턴을 더 명확하게 만들어 줍니다. 예를 들어, 텍스트 복합 알고리즘을 위해서 전략 패턴을 사용해야 한다면, `SimpleLayoutStrategy`나 `TeXLayoutStrategy`의 클래스를 정의해야 합니다.
5. 클래스를 정의하세요.
  - 클래스의 인터페이스를 선언하고, 상속 관계를 확립하며, 데이터와 객체 참조를 나타내는 인스턴스 변수를 정의합니다. 이미 설계한 클래스에 패턴을 적용하려면 영향을 받는 클래스들을 식별하여 적당하게 수정해야 합니다.
6. 패턴에 정의한 연산에 대해서 응용프로그램에 적합한 이름을 정의하세요.
  - 다시 패턴의 이름을 응용프로그램에 적합한 형태로 바꿔야 합니다. 각 연산의 협력 방법이나 책임을 참조해서 연산의 이름을 결정하세요. 이름을 부여하는 규칙은 항상 일정해야 합니다. 예를 들어, 팩토리 메서드 패턴을 표헌하기 위해서 "접두어 'create'을 사용할 수 있다"와 같은 규칙을 만들어 두는 것입니다.
7. 패턴에 정의한 책임과 협력 방법을 수행하도록 연산을 구현합시다.
  - 패턴별로 설명해 놓은 구현 부분은 여러분이 패턴을 구현할 때 도움을 줄 것입니다. '예제 코드' 절에 제시한 예제들도 도움이 될 것입니다.
  - 앞의 내용들은 여러분이 처음 시작하는 데 참고해야 할 지침에 불과합니다. 시간이 흐르면 여러분은 자신만의 방법으로 디자인 패턴을 이용할 수 있게 될 것입니다.
  - 디자인 패턴을 어떻게 사용하는지에 대한 논의에서 패턴을 언제 사용하지 않아야 하는지에 대한 언급이 빠져서는 안 될 것입니다. 디자인 패턴은 아무렇게나 적용되어서는 안 됩니다. 종종 디자인 패턴은 간접 접근(위임과 같은 기법)을 도입함으로써 융통성과 다양성을 갖지만, 설계를 복잡하게 만들고 성능을 떨어뜨리는 결과를 가져오기도 합니다. 따라서 어떤 디자인 패턴을 적용하려면, 그 패턴이 허용하는 유연성이 진짜로 필요할 때 적용해야 합니다. 그리고 어떤 패턴을 썼을 때 얻는 부분과 잃는 부분이 무엇인지 평가할 때는 '결과' 절을 잘 읽어보세요. 도움을 받을 수 있을 겁니다.

## 표 1.2
디자인 패턴을 통해 다양화할 수 있는 설계 측면
|목적|디자인 패턴|이 패턴을 통해 다양화할 수 있는 부분|
|---|---|---|
|생성|[3.1 추상 팩토리(Abstract Factory)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter03/3-1.md)|제품 객체군|
|생성|[3.2 빌더(Builder)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter03/3-2.md)|복합 객체 생성 방법|
|생성|[3.3 팩토리 메서드(Factory Method)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter03/3-3.md)|인스턴스화될 객체의 서브클래스|
|생성|[3.4 원형(Prototype)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter03/3-4.md)|인스턴스화될 객체 클래스|
|생성|[3.5 단일체(Sigleton)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter03/3-5.md)|클래스의 인스턴스가 하나일 때|
|구조|[4.1 적응자(Adapter)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-1.md)|객체에 대한 인터페이스|
|구조|[4.2 가교(Bridge)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-2.md)|객체 구현|
|구조|[4.3 복합체(Composite)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-3.md)|객체의 합성과 구조|
|구조|[4.4 장식자(Decorator)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-4.md)|서브클래싱 없이 객체의 책임성|
|구조|[4.5 퍼사드(Facade)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-5.md)|서브시스템에 대한 인터페이스|
|구조|[4.6 플라이급(Flyweight)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-6.md)|객체의 저장 비용|
|구조|[4.7 프록시(Proxy)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter04/4-7.md)|객체 접근 방법|
|행동|[5.1 책임 연쇄(Chain of Responsibility)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-1.md)|요청을 처리하는 객체|
|행동|[5.2 명령(Command)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-2.md)|요청의 처리 시점과 처리 방법|
|행동|[5.3 해석자(Interpreter)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-3.md)|언어의 문법과 해석 방법|
|행동|[5.4 반복자(Iterator)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-4.md)|집합 객체 요소들의 접근 방법 및 순회 방법|
|행동|[5.5 중재자(Mediator)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-5.md)|어떤 객체들이 어떻게 상호작용하는지|
|행동|[5.6 메멘토(Memento)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-6.md)|언제 어떤 정보를 객체의 외부에 저장하는지|
|행동|[5.7 감시자(Observer)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-7.md)|다른 객체에 종속적인 객체수<br>종속적인 객체들의 상태 변경 방법|
|행동|[5.8 상태(State)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-8.md)|객체의 상태|
|행동|[5.9 전략(Strategy)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-9.md)|알고리즘|
|행동|[5.10 템플릿 메서드(Template Method)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-10.md)|알고리즘의 단계|
|행동|[5.11 방문자(Visitor)](https://github.com/wonder13662/my-books/blob/writing/GOF-design-patterns/Chapter05/5-11.md)|클래스의 변경 없이 객체에 적용할 수 있는 연산|